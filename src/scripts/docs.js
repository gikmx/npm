// Native
import PATH from 'path';
import FS from 'fs';
// NPM
import HandleBars from 'handlebars';
import Git from 'nodegit';
import Tmp from 'tmp';
import JSDoc2Md from 'jsdoc-to-markdown';
import { $, Subject } from '@gik/tools-streamer';
// Local
import Path from '../path';
import { $fromConfig, Package } from '../config';

/**
 * @module docs
 * @memberof gik.Scripts
 * @type {script}
 * @description Generates documentation using [js-to-markdown](http://github.com/jsdoc-to-markdown/jsdoc-to-markdown).
 * The template used for the documentation is customised, you can see how it looks here,
 * since this very documentation was generated by it. This is why even though this script
 * uses js-to-markdown several of their configuration properties are not available due to
 * the heavy customisation it was done to its original template. However the following
 * ARE available.
 *
 * ###### Default `jsdoc.json` config
 * ```javascript
 * <<<file:root/.jsdocrc>>>
 * ````
 * @property {Object} jsdoc - Options for the documentation generator.
 * @property {string} [jsdoc.template=./template/README.md] - The location of documentation
 * template.
 * @property {boolean} [private=false] - Whether to show private members or not.
 * @property {string} [configure=root/.jsdocrc] - An example of the base configuration is
 * shown below.
 *
 * @returns {gik.Types.Observable} - An observable which `gik` will subscribe to
 * in order to execute it.
 *
 * @todo Add documentation about how to customize the template and the available helpers.
 */
export default function $fromScriptDocs() {

    const filename = 'README.md';

    // Converts the config$ into a hot observable, so it only runs once.
    const subject = new Subject();
    $fromConfig().subscribe(subject);
    const config$ = new $(observer => subject.subscribe(observer));

    const body$ = config$
        .map(config => ({
            ...config[Package.name].jsdoc,
            files: config[Package.name].jsdoc.files
                ? config[Package.name].jsdoc.files
                : PATH.join(PATH.resolve(config.directories.src), '**', '*.js'),
        }))
        .switchMap(config => $
            .fromFileRead(config.template)
            .map(template => ({ ...config, template })),
        )
        // Apply fixes (cof cof hacks)
        .switchMap((config) => {
            // for some reason if the private config comes as false, babel breaks.
            // so it's either true  or undefined.
            config.private = !!config.private || undefined;
            // jsdocrc specifies a "node_modules" path that only works relative to its
            // location. This is a problem because when using this on other projects
            // the location for the plugins will change. Normally this would be easily
            // fixed by using .jsdoc.js file and determining the path dynamically, but
            // js-to-markdown breaks when given a non-json file. So, to fix this we alter
            // the contents dinamically, store them on a tmpfile and use that instead.
            const tmpname$ = $.bindNodeCallback(Tmp.tmpName)();
            const jsdocrc$ = $
                .fromFileRead(config.configure)
                .map((contents) => {
                    let path = require.resolve('jsdoc-babel');
                    path = path.slice(0, path.lastIndexOf('node_modules') + 12);
                    return contents.replace(/node_modules/g, path);
                });
            return $
                .combineLatest(tmpname$, jsdocrc$)
                .switchMap(([path, content]) => $
                    .fromFileWrite(path, content)
                    .mapTo({ ...config, configure: path }),
                );
        })
        .switchMap(config => $.fromPromise(JSDoc2Md.render(config)))
        // convert raw handlebars blocks back no normal, so the seconf pass can process'em
        // .map(content => content.replace(/\\)\{\{\{/g, '{{{'));
        .map((content) => {
            if (content.indexOf('<<<file:') === -1) return content;
            return content.replace(/<<<file:([^>]+)>>>/g, (str, match) => {
                const [dir, base] = match.split('/');
                // TODO: This should be done async using streams.
                return FS.readFileSync(PATH.join(Path[dir], base), 'utf-8');
            });
        });

    const header$ = config$
        // verify if the user has created a template and used,or fallback to base.
        .switchMap(config => $
            .fromAccess(PATH.join(PATH.resolve(config.directories.template), filename))
            .switchMap(path => path
                ? $.of(path)
                : $.fromAccess(PATH.join(Path.template, filename)),
            )
            .switchMap((path) => {
                if (!path) throw new Error(`${filename} template could not be found.`);
                return $.fromFileRead(path);
            }),
        );

    const output$ = $
        .combineLatest(body$, header$, config$)
        // Compile using HandleBars static instance set by jsdoc-to-markdown
        // NOTE: every helper registered with jsdoc-to-markdown will be available
        .map(([body, header, config]) => HandleBars.compile(`${header}\n${body}`)(config))
        .switchMap(content => $.fromFileWrite(PATH.join(Path.cwd, filename), content));

    const add2repo = path => $
        .from(Git.Repository.open(Path.cwd))
        .switchMap(repo => $
            .from(repo.index())
            .switchMap(index => $
                .from(index.addByPath(path))
                .mapTo(index),
            )
            .switchMap(index => $.from(index.write()))
            .mapTo(path),
        );

    return output$
        .mapTo(PATH.join('.', filename))
        .switchMap(add2repo)
        .map(path => ({
            status: 0,
            message: `Docs generated on ${path} and added to Git`,
        }));
}
